webpackJsonp([0xa97b735f266f],{567:function(n,a){n.exports={data:{markdownRemark:{frontmatter:{title:"Solve AWS Lambda timeout limitations",date:"2018-10-25T22:00:00.000Z",tags:["AWS","Serverless","Docker","ECS","JavaScript"]},timeToRead:6,html:'<p>As I\'ve been drafting a strategy to <a href="/solving-aws-lambda-timeouts-fargate">solve the AWS Lambda timeout limitations</a> I felt I\'m getting closer to solving an issue which keeps me away from sleeping well sometimes. True that there are known patterns for <a href="https://www.jeremydaly.com/serverless-microservice-patterns-for-aws/">reaching higher scalability using SQS</a> though the problems at hand were not easy to solve with either of those when the AWS Lambda is used as a core compute service.</p>\n<p>During the same period of me focusing on the timeout limitations issue, <a href="https://aws.amazon.com/about-aws/whats-new/2018/10/aws-lambda-supports-functions-that-can-run-up-to-15-minutes/">AWS raised the limit to 15 minutes</a>. Although this is surely a useful change, I still preferred to polish my draft strategy of using a non-lambda compute which will not have a limit at all. When the safety-net-compute is also based on a per-demand pricing model, this forms a real solution to the problem. In reality, sometimes it\'s impossible to predict load up front and maxing out limits is not the ultimate solution.</p>\n<h2 id="notable-improvements"><a href="#notable-improvements" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Notable improvements</h2>\n<p>Here\'s a short overview of the most important improvements I\'ve made between draft implementation and current one:</p>\n<ul>\n<li><a href="https://www.npmjs.com/package/unzip">unzip</a> has been swapped to <a href="https://www.npmjs.com/package/unzipper">unzipper</a> for a <a href="https://github.com/EvanOxfeld/node-unzip/issues/120">good reason</a>. API is same.</li>\n<li>Logic gluing primary and secondary lambda handlers has been changed. Instead of using naming conventions which are an easy to mistake constraint, I\'ve put in place a mapping "cheatsheet".</li>\n<li><a href="https://github.com/gmetzker/serverless-plugin-lambda-dead-letter">serverless-plugin-lambda-dead-letter</a> dependency, which looked promising, was removed in favour of native functionalities of CloudFormation. Main reason: <a href="https://github.com/gmetzker/serverless-plugin-lambda-dead-letter/issues/37">issues with intrinsic functions</a>.</li>\n<li><code class="language-text">event</code> and <code class="language-text">context</code> from primary handler have been moved to environment variables passed through <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerOverride.html">ContainerOverride</a> API because information from original JSON objects was getting dropped during the process of executing <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html">runTask</a>. This is also an improvement in terms of consistency of managing environment variables.</li>\n<li>Use original environment variables from primary handler through the same <a href="https://docs.aws.amazon.com/lambda/latest/dg/API_GetFunction.html">GetFunction</a> which yields this <a href="https://docs.aws.amazon.com/lambda/latest/dg/API_EnvironmentResponse.html?shortFooter=true">configuration</a> together with the location of the source of the primary handler already fetched.</li>\n<li>A helper to handle varying <code class="language-text">event</code> structures has been added. Appears that an SNS event changes from a bucket to bucket depending on the way files are managed within bucket.</li>\n</ul>\n<p>Skeleton of the end implementation can be seen in this <a href="https://github.com/kalinchernev/immortal-aws-lambda">repository</a>.</p>\n<h2 id="implementation"><a href="#implementation" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Implementation</h2>\n<p>So how does the current implementation look like after the before-mentioned improvements?</p>\n<p>From a bird\'s-eye view, structure and main ideas are the same:</p>\n<div class="gatsby-highlight" data-language="sh">\n      <pre class="language-sh"><code class="language-sh">immortal-aws-lambda\n├── container\n│   ├── Dockerfile\n│   ├── package.json\n│   ├── README.md\n│   └── runner.js\n└── serverless\n    ├── package.json\n    ├── README.md\n    ├── serverless.yml\n    ├── src\n    │   ├── events\n    │   │   └── onFailure.js\n    │   └── lib\n    │       ├── extractors.js\n    │       ├── getHandlerData.js\n    │       └── snsTopicToHandlerMap.js\n    └── webpack.config.js\n\n5 directories, 12 files</code></pre>\n      </div>\n<h3 id="immortal-aws-lambda-container-service"><a href="#immortal-aws-lambda-container-service" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><a href="https://github.com/kalinchernev/immortal-aws-lambda/tree/master/container">Immortal AWS Lambda: Container Service</a></h3>\n<p>Probably you\'ll want to create the ECS task in AWS console first and take some settings you\'ll need for the serverless service.</p>\n<p>The sole goal of this service is to put a <code class="language-text">runner.js</code> script in a container and run it remotely from the dead letter queue service.</p>\n<p>The contents of the script is actually ultra-thin and is comprised of 3 main steps:</p>\n<ol>\n<li>Take initial source code of a lambda handler</li>\n<li>Take environment variables of the same handler</li>\n<li>Run the handler</li>\n</ol>\n<p>All settings are dynamic variables.</p>\n<p>And the source is ultra-simple:</p>\n<div class="gatsby-highlight" data-language="javascript">\n      <pre class="language-javascript"><code class="language-javascript">#<span class="token operator">!</span><span class="token operator">/</span>usr<span class="token operator">/</span>bin<span class="token operator">/</span>env node\n\n<span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'path\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> https <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'https\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> <span class="token constant">AWS</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'aws-sdk\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> promisePipe <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'promisepipe\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> unzip <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'unzipper\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> runner <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> <span class="token punctuation">{</span>\n    <span class="token constant">REGION</span><span class="token punctuation">,</span>\n    <span class="token constant">AWS_LAMBDA_HANDLER_EVENT</span><span class="token punctuation">,</span>\n    <span class="token constant">AWS_LAMBDA_HANDLER_CONTEXT</span><span class="token punctuation">,</span>\n    <span class="token constant">AWS_LAMBDA_HANDLER_NAME</span><span class="token punctuation">,</span>\n    <span class="token constant">AWS_LAMBDA_HANDLER_PATH</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span> <span class="token operator">=</span> process<span class="token punctuation">.</span>env<span class="token punctuation">;</span>\n\n  <span class="token keyword">try</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> event <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token constant">AWS_LAMBDA_HANDLER_EVENT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">const</span> context <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token constant">AWS_LAMBDA_HANDLER_CONTEXT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">const</span> lambda <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AWS<span class="token punctuation">.</span>Lambda</span><span class="token punctuation">(</span><span class="token punctuation">{</span> region<span class="token punctuation">:</span> <span class="token constant">REGION</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">const</span> lambdaInfo <span class="token operator">=</span> <span class="token keyword">await</span> lambda\n      <span class="token punctuation">.</span><span class="token function">getFunction</span><span class="token punctuation">(</span><span class="token punctuation">{</span> FunctionName<span class="token punctuation">:</span> <span class="token constant">AWS_LAMBDA_HANDLER_NAME</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">promise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">const</span> sourceCodeSignedUrl <span class="token operator">=</span> lambdaInfo<span class="token punctuation">.</span>Code<span class="token punctuation">.</span>Location<span class="token punctuation">;</span>\n\n    <span class="token keyword">return</span> https<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>sourceCodeSignedUrl<span class="token punctuation">,</span> <span class="token keyword">async</span> res <span class="token operator">=></span> <span class="token punctuation">{</span>\n      <span class="token comment">// Download source from cloud and extract it at the current directory at the same time.</span>\n      <span class="token keyword">await</span> <span class="token function">promisePipe</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> unzip<span class="token punctuation">.</span><span class="token function">Extract</span><span class="token punctuation">(</span><span class="token punctuation">{</span> path<span class="token punctuation">:</span> __dirname <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n      <span class="token keyword">const</span> pathToHandler <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>\n        <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>__dirname<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token constant">AWS_LAMBDA_HANDLER_PATH</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span>\n      <span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n      <span class="token comment">// eslint-disable-next-line</span>\n      <span class="token keyword">const</span> handler <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span>pathToHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n      <span class="token comment">// Merge environment variables.</span>\n      process<span class="token punctuation">.</span>env <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>\n        <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>\n        process<span class="token punctuation">.</span>env<span class="token punctuation">,</span>\n        lambdaInfo<span class="token punctuation">.</span>Configuration<span class="token punctuation">.</span>Environment<span class="token punctuation">.</span>Variables\n      <span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n      <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">await</span> handler<span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">return</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token function">runner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<h3 id="immortal-aws-lambda-serverless-service"><a href="#immortal-aws-lambda-serverless-service" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><a href="https://github.com/kalinchernev/immortal-aws-lambda/tree/master/serverless">Immortal AWS Lambda: Serverless Service</a></h3>\n<p>This is the serverless service to deploy. It\'s as simple and independent as it could be:</p>\n<ul>\n<li>Provides a dead letter queue <code class="language-text">LambdaFailureQueue</code> to which others can push messages when failing.</li>\n<li>Exports the ARN of the queue in order for other services to be able to import the value of the ARN. (<a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/outputs-section-structure.html">docs</a>)</li>\n<li>All the other details about the <code class="language-text">iamRoleStatements</code>, <code class="language-text">events</code> subscriptions and settings remain the same as before.</li>\n</ul>\n<p>Helpers in <code class="language-text">lib</code> are your responsibility to implement as <code class="language-text">event</code> structures in your case will be different. (most probably)</p>\n<p>Still, the main point of having this service is still to run an ECS task starting a container:</p>\n<div class="gatsby-highlight" data-language="javascript">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> runParams <span class="token operator">=</span> <span class="token punctuation">{</span>\n  taskDefinition<span class="token punctuation">:</span> <span class="token constant">RUNNER</span><span class="token punctuation">,</span>\n  launchType<span class="token punctuation">:</span> <span class="token string">"FARGATE"</span><span class="token punctuation">,</span>\n  networkConfiguration<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    awsvpcConfiguration<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n      assignPublicIp<span class="token punctuation">:</span> <span class="token string">"ENABLED"</span><span class="token punctuation">,</span>\n      subnets<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token constant">SUBNET</span><span class="token punctuation">]</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  overrides<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    containerOverrides<span class="token punctuation">:</span> <span class="token punctuation">[</span>\n      <span class="token punctuation">{</span>\n        environment<span class="token punctuation">:</span> <span class="token punctuation">[</span>\n          <span class="token punctuation">{</span>\n            name<span class="token punctuation">:</span> <span class="token string">"AWS_LAMBDA_HANDLER_EVENT"</span><span class="token punctuation">,</span>\n            value<span class="token punctuation">:</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>initialMessage<span class="token punctuation">)</span>\n          <span class="token punctuation">}</span><span class="token punctuation">,</span>\n          <span class="token punctuation">{</span>\n            name<span class="token punctuation">:</span> <span class="token string">"AWS_LAMBDA_HANDLER_CONTEXT"</span><span class="token punctuation">,</span>\n            value<span class="token punctuation">:</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span>\n          <span class="token punctuation">}</span><span class="token punctuation">,</span>\n          <span class="token punctuation">{</span>\n            name<span class="token punctuation">:</span> <span class="token string">"AWS_LAMBDA_HANDLER_NAME"</span><span class="token punctuation">,</span>\n            value<span class="token punctuation">:</span> handlerData<span class="token punctuation">.</span>name\n          <span class="token punctuation">}</span><span class="token punctuation">,</span>\n          <span class="token punctuation">{</span>\n            name<span class="token punctuation">:</span> <span class="token string">"AWS_LAMBDA_HANDLER_PATH"</span><span class="token punctuation">,</span>\n            value<span class="token punctuation">:</span> handlerData<span class="token punctuation">.</span>path\n          <span class="token punctuation">}</span>\n        <span class="token punctuation">]</span><span class="token punctuation">,</span>\n        name<span class="token punctuation">:</span> <span class="token constant">RUNNER</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">]</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token keyword">await</span> ecs<span class="token punctuation">.</span><span class="token function">runTask</span><span class="token punctuation">(</span>runParams<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">promise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p>Don\'t forget to take these settings from the AWS Console and set them in your <code class="language-text">serverless.yaml</code> configuration file.</p>\n<h3 id="integrating-services-in-the-workflow"><a href="#integrating-services-in-the-workflow" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Integrating services in the workflow</h3>\n<p>"Attaching" other serverless services and handlers to this workflow boils down the following:</p>\n<ol>\n<li>Allow the service to push messages to the SQS dead letter queue:</li>\n</ol>\n<div class="gatsby-highlight" data-language="yaml">\n      <pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">iamRoleStatements</span><span class="token punctuation">:</span>\n  <span class="token comment"># Allow queueing messages to the DLQ https://docs.aws.amazon.com/lambda/latest/dg/dlq.html</span>\n  <span class="token punctuation">-</span> <span class="token key atrule">Effect</span><span class="token punctuation">:</span> <span class="token string">\'Allow\'</span>\n    <span class="token key atrule">Action</span><span class="token punctuation">:</span>\n      <span class="token punctuation">-</span> sqs<span class="token punctuation">:</span>SendMessage\n    <span class="token key atrule">Resource</span><span class="token punctuation">:</span> <span class="token string">\'*\'</span></code></pre>\n      </div>\n<ol start="2">\n<li>Add ARN information about the SQS queue from <code class="language-text">Resources</code> section</li>\n</ol>\n<div class="gatsby-highlight" data-language="yaml">\n      <pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">resources</span><span class="token punctuation">:</span>\n  <span class="token key atrule">Resources</span><span class="token punctuation">:</span>\n    <span class="token key atrule">fooFunction</span><span class="token punctuation">:</span>\n      <span class="token key atrule">Type</span><span class="token punctuation">:</span> <span class="token string">"AWS::Lambda::Function"</span>\n      <span class="token key atrule">Properties</span><span class="token punctuation">:</span>\n        <span class="token key atrule">DeadLetterConfig</span><span class="token punctuation">:</span>\n          <span class="token key atrule">TargetArn</span><span class="token punctuation">:</span>\n            <span class="token key atrule">Fn::ImportValue</span><span class="token punctuation">:</span> immortal<span class="token punctuation">-</span>aws<span class="token punctuation">-</span>lambda<span class="token punctuation">:</span>LambdaFailureQueue</code></pre>\n      </div>\n<p>This is because the serverless framework does not yet support <a href="https://www.trek10.com/blog/dead-letter-config/"><code class="language-text">onError</code></a> properly. Thanks to <a href="https://github.com/neowulf">Siva Kommuri</a> for <a href="https://github.com/neowulf">suggesting this workaround</a>.</p>\n<p>Now, when your service fails, the error will be queued to the dead letter queue provided by the immortal aws lambda service, the immortal service will take this message, find the right handler and call it via the container service.</p>\n<h2 id="final-thoughts"><a href="#final-thoughts" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Final thoughts</h2>\n<p>My path to finding this solution was not easy.</p>\n<p>The tools involved are having rough edges.</p>\n<p>Also, the process of triggering and reproducing failures because of a timeout, rebuilding the container, etc. is a lenghtly procedure on each iteration. For instance, every time something fails because of a missing character or spelling mistake, I needed to redeploy the non-bundles and non-optimized code of the lambda function to the cloud in order to get merely adequate error message for debugging in the logs of the ECS. (crazy!)</p>\n<p>Working with streams and promises in Node is still very painful and hard to debug by the way ...</p>\n<p>So I hope that having these very thin layers of variables which communicate to each other will be a feasible solution for solving the timeout limitations in AWS Lambda for months ahead.</p>'}},pathContext:{slug:"solve-aws-lambda-timeout-limitations"}}}});
//# sourceMappingURL=path---solve-aws-lambda-timeout-limitations-a6a62b359c3de3a08e02.js.map